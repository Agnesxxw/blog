(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{733:function(t,r,a){"use strict";a.r(r);var e=a(12),o=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"阻塞-非阻塞-与-同步-异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞-非阻塞-与-同步-异步"}},[t._v("#")]),t._v(" 阻塞/非阻塞 与 同步/异步")]),t._v(" "),a("p",[t._v("在开始前，首先要了解阻塞/非阻塞、同步/异步这 2 组概念的区别。")]),t._v(" "),a("p",[a("strong",[t._v("对于阻塞/非阻塞")]),t._v("：说的是程序等待结果时的状态。阻塞是结果返回前，程序会挂起；非阻塞是是程序不会一直挂起，先去做别的事情。")]),t._v(" "),a("p",[a("strong",[t._v("对于同步/异步")]),t._v("：在操作系统处理 I/O 的时候，阻塞和非阻塞都是同步的 I/O。只有少数的 API 才是异步 I/O。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6n4kqwupj30bj046aae.jpg",alt:""}})]),t._v(" "),a("p",[a("strong",[t._v("对于这 2 组概念时，要注意讨论的上下文")]),t._v("。以 nodejs 为例，对于开发者来说，它是 非阻塞+异步 编程模型；对于 nodejs 实现来说，它底层是以 非阻塞+同步 的 "),a("code",[t._v("epoll")]),t._v(" 来实现的。")]),t._v(" "),a("p",[t._v("知乎上有关于这个问题的讨论："),a("a",{attrs:{href:"https://www.zhihu.com/question/19732473",target:"_blank",rel:"noopener noreferrer"}},[t._v("怎么理解阻塞非阻塞和同步异步的区别"),a("OutboundLink")],1),t._v("。注意下有些高赞答案不一定是对的。")]),t._v(" "),a("h3",{attrs:{id:"reactor-与-proactor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reactor-与-proactor"}},[t._v("#")]),t._v(" Reactor 与 Proactor")]),t._v(" "),a("p",[t._v("通俗来讲，对于高性能服务器来说，它首先要保证是非阻塞的，即：调用外部资源，不管结果如何，不会阻挡线程继续进行。")]),t._v(" "),a("p",[t._v("如果底层接口是同步的，那么数据已经被读到内核缓存，需要我们主动将其从内核缓存读到用户空间（进程空间）；如果底层接口是异步的，那么数据到内核缓存，再到进程空间，我们可以直接取到数据。")]),t._v(" "),a("p",[t._v("Reactor 就是非阻塞+同步网络模型，Proactor 就是非阻塞+异步网络模型。理论上看，肯定 Proactor 效率更高，但是 Linux 下的 AIO 不完善，Reactor 更加通用。")]),t._v(" "),a("p",[t._v("通俗来讲（请自动对应内核缓存和用户空间）：")]),t._v(" "),a("ul",[a("li",[t._v("Reactor：拿号，某个柜台空闲了就通知我去取款，我还是必须坐到柜台前取款，取款过程还是同步的。")]),t._v(" "),a("li",[t._v("Proactor：拿号，告诉大堂经理我要取款，款到了，大唐经理送到我手中，取款过程是异步的。")])]),t._v(" "),a("p",[t._v("除此之外，高性能服务器需要创建线程/进程池，保证复用。")]),t._v(" "),a("h3",{attrs:{id:"再看阻塞-非阻塞-和-同步-异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#再看阻塞-非阻塞-和-同步-异步"}},[t._v("#")]),t._v(" 再看阻塞/非阻塞 和 同步/异步")]),t._v(" "),a("p",[t._v("在前面说明的基础上，会发现：阻塞/非阻塞说的是在调用外部资源时，线程是否能继续执行，无需等待。如果可以，那么就是非阻塞。")]),t._v(" "),a("p",[t._v("在非阻塞模型下，当调用完成时，线程会收到“通知”。如果底层用的是同步 IO，线程接到“通知”还在自己调用接口（例如 "),a("code",[t._v("read()")]),t._v(" ）去取出数据；如果底层用的是异步 IO，线程接到的“通知”就是数据，数据已经被操作系统取到了用户空间。")]),t._v(" "),a("p",[a("em",[t._v("其实没那么难，只是容易被误导。")])]),t._v(" "),a("p",[t._v("如果你想看示例代码，请参考："),a("a",{attrs:{href:"http://php-note.com/article/833.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("彻底理解：阻塞、非阻塞、同步、异步、Reactor、Proactor"),a("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=o.exports}}]);