(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{788:function(t,r,a){"use strict";a.r(r);var e=a(12),_=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[t._v("#")]),t._v(" 场景")]),t._v(" "),a("p",[t._v("目前，主流db都支持事务。但事务保证完全ACID是有代价的。")]),t._v(" "),a("p",[t._v("所以有时候会为了性能，在某些场景种，弱化事务的ACID。这是通过"),a("strong",[t._v("设置不同的隔离级别")]),t._v("来实现的。")]),t._v(" "),a("p",[t._v("不同的隔离级别能解决不同的读写异常场景，要了解这些读写异常场景，才能根据情况选择合适的隔离级别。")]),t._v(" "),a("h2",{attrs:{id:"脏读（读取未提交的数据）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#脏读（读取未提交的数据）"}},[t._v("#")]),t._v(" 脏读（读取未提交的数据）")]),t._v(" "),a("p",[t._v("如果一个事务A向数据库写了数据，但事务还没提交或终止，另一个事务B就看到了事务A写进数据库的数据，这就是脏读。")]),t._v(" "),a("h2",{attrs:{id:"读偏-不可重复读（前后多次读取，数据内容不一致）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读偏-不可重复读（前后多次读取，数据内容不一致）"}},[t._v("#")]),t._v(" 读偏 / 不可重复读（前后多次读取，数据内容不一致）")]),t._v(" "),a("p",[t._v("事务A读取数据，此时为20；事务B执行数据更新，变为30并且提交；事务A还没结束，需要再次读取数据，此时为30。")]),t._v(" "),a("p",[a("strong",[t._v("对比脏读")]),t._v("：脏读是读取另一个事务未提交事务，不可重复读是在一次事务中，读到两种数据状态。")]),t._v(" "),a("h2",{attrs:{id:"幻读（前后多次读取，数据总量不一致）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#幻读（前后多次读取，数据总量不一致）"}},[t._v("#")]),t._v(" 幻读（前后多次读取，数据总量不一致）")]),t._v(" "),a("p",[t._v("一个事务的写入改变了另一个事务的查询结果的正确性，这就是幻读。")]),t._v(" "),a("p",[t._v("例如：第一个事务读取一个结果集后，第二个事务，对这个结果集经行增删操作并提交；然而第一个事务中再次对这个结果集进行查询时，数据发现丢失或新增。")]),t._v(" "),a("h2",{attrs:{id:"脏写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#脏写"}},[t._v("#")]),t._v(" 脏写")]),t._v(" "),a("p",[t._v("当两个事务同时尝试去更新某一条数据记录时，就肯定会存在一个先一个后。而当事务A更新时，事务A还没提交，事务B就也过来进行更新，覆盖了事务A提交的更新数据，这就是脏写。")]),t._v(" "),a("h2",{attrs:{id:"更新丢失"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新丢失"}},[t._v("#")]),t._v(" 更新丢失")]),t._v(" "),a("p",[t._v("两个事务并发写入的时候，其中一个事务的修改可能丢失，因为写入的内容没有包括第一个事务的修改。")]),t._v(" "),a("p",[t._v("例如：事务A和B同时读取到数据a，将其更新为b，同时提交，那么A和B只有一个会成功。")]),t._v(" "),a("h2",{attrs:{id:"写偏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写偏"}},[t._v("#")]),t._v(" 写偏")]),t._v(" "),a("p",[t._v("假设公司里可以同时有多位员工值班，但至少有一位员工在值班。员工可以申请不值班，只要至少有一个同事正在值班，申请即可通过。")]),t._v(" "),a("p",[t._v("此时，小明和小红是两位值班员工。他们都决定请假，恰好在同一时间点击按钮下班。")]),t._v(" "),a("p",[t._v("创建两个事务，应用首先检查是否有两个或以上的员工正在值班。两个事务的读取都返回当前值班员工数量为2。所以小明/小红都成功更新自己的记录休班了，两个事务更新成功。")]),t._v(" "),a("p",[t._v("但是结果是不满足最初设定的条件：至少有一位员工在值班。")]),t._v(" "),a("h2",{attrs:{id:"参考链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[t._v("#")]),t._v(" 参考链接")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"http://www.zhai14.com/blog/strenghen-comprehension-on-dirty-read-and-phantom.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("加深对脏读、脏写、可重复读、幻读的理解"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/69380112",target:"_blank",rel:"noopener noreferrer"}},[t._v("通俗易懂 事务、ACID、脏读、脏写、幻读、读已提交、快照隔离、读写锁、两阶段锁定 的区别与联系"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1450773",target:"_blank",rel:"noopener noreferrer"}},[t._v("快速理解脏读、不可重复读、幻读和MVCC"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://xie.infoq.cn/article/4e7de8ce0607bfbe24a5c2e16",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据库的乐观锁和悲观锁并非真实的锁"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=_.exports}}]);